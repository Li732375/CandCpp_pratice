#include <iostream> 
using namespace std; 

int main() {
    // 變數建立後會配置記憶體空間，這類資源是配置在記憶體的堆疊區（Stack），
    // 生命週期侷限於函式執行期間，也就是函式執行過後，配置的空間就會自動清除。

    // 以動態方式配置一個 int 型態大小的記憶體。
    int *p = new int; // 只配置空間但不初始空間的值。
    int *p1 = new int(100); // 配置空間且初始化。

    // 若要將函式執行結果傳回，不能直接傳回這類被自動配置空間的位址，
    // 因為函式執行過後，該空間就會釋出，函式呼叫者後續若透過位址取用
    // 這些資源，會發生不可預期的結果。

    // 開發者得自行在需要的時候配置記憶體，這些記憶體會被配置在堆積區（Heap），
    // 不會自動清除，開發者得在不使用資源時自行刪除記憶體。

    cout << "空間位址：" << p1 << endl 
         << "儲存的值：" << *p1 << endl; 

    *p1 = 200; 

    cout << "空間位址：" << p1 << endl 
         << "儲存的值：" << *p1 << endl; 

    // 使用 new 動態配置的空間，在程式結束前不會自動歸還，
    // 必須使用 delete 將空間歸還。
    delete p;
    delete p1;

    // 配置了 1000 個 int 大小的空間，並傳回空間的第一個位址，
    // 配置後的空間資料是未知的，[] 中指定的長度可以是來自於運
    // 算式，不必是編譯時期就得決定的值，這個值必須自行儲存下來
    // ，因為沒有任何方式，可以從 p 得知到底配置的長度是多少。

    // 即便 delete，變數名稱也不能重新利用。
    //int *p = new int[1000]; // error: redeclaration of 'int* p'

    // 如果想在配置連續空間後指定每個空間的初值，可以使用 {}。
    int *p2 = new int[3]{10, 20, 30};

    // 如果要全部設定為型態的零值。
    int *p3 = new int[3]();

    // 不使用時要使用 delete[] 歸還給記憶體，必須加上 []，
    // 表示歸還的是整個連續空間。
    delete [] p2;
    delete [] p3;

    // 在一個陣列的例子。
    int size = 0; 

    cout << "輸入長度："; 
    cin >> size; 
    int *arr = new int[size]{0}; 

    cout << "指定元素：" << endl; 
    for(int i = 0; i < size; i++) { 
        cout << "arr[" << i << "] = "; 
        cin >> arr[i]; 
    } 

    cout << "顯示元素值：" << endl; 
    for(int i = 0; i < size; i++) {
        cout << "arr[" << i << "] = " << arr[i]
             << endl; 
    } 
    delete [] arr; 


    // 若要動態配置連續空間，並當成二維陣列來操作，
    // 就記得二維（或多維）陣列，就是以陣列的陣列來
    // 實作。
    int **arr1 = new int*[2];
    // 現在 arr1[0]、arr1[1] 可以分別儲存一維陣列位址，目前尚未初始，
    // 若每段一維陣列的長度是 3，可以如下動態配置，並將一維陣列每個
    // 元素初始設為 0 。
    for(int i = 0; i < 2; i++) {
        arr1[i] = new int[3]{0};
    }

    // 最後要刪除配置的空間時，也要如以上範例逐一刪除。
    for(int i = 0; i < 2; i++) {
        delete [] arr1[i];
    }
    delete [] arr1; 

    return 0; 
}